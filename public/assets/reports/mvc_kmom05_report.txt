<article class="hashView">

    <h2>MVC Kmom05</h2>
        <h3>Generella intryck och egna reflektioner</h3>
        <p>Databaser med php, en potentiell mardrömskombination som visade sig vara en fröjd eftersom att nästan alla komponenter runtomkring (formulär, CRUD, klasser, router) nu är bekant materia.
		Även denna gång ett logiskt upplägg med målbild och sedan anpassning i egen tillämpning där man kunde återanvända mycket kod från övningen vilket är skönt då
		man slipper fastna i grundläggande delar (eftersom att man kan kolla i sin "referens" - övningen) och istället kan lägga fokus på att skapa funktionalitet.
		Jag är nu även mer bekant med GET/POST och vet vad jag förväntas göra när jag läser övningen utan att behöva sätta mig in i ett nytt koncept, samma med CRUD.
		Kanske har jag nått någon form av kritisk massa för nybörjare som gör att allt inte känns openetrerbart längre, skönt i sådana fall!</p>

		<p>Jag valde att använda SQLite3-databasen eftersom att jag redan provat på MariaDB i databasteknologikursen. Syntaxen för SQL:en känns igen (även om jag bara behövde den för att kontrollera min databas vid uppdateringsfel),
		ORM-modellen upplevde jag vara enklare att hantera även om jag villigt ska erkänna att jag upplever det som sker bakom kulisserna, i <i>ManagerRegistry</i> och <i>Repository</i>, som någon form av magi. Jag har antagligen en hel del läsning kvar att göra i dokumentationen för att greppa det hela.
		Om jag skulle försöka mig på en jämförelse med tidigare databaser känns det som att <i>Repository</i> ersätter själva databasen och <i>ManagerRegistry</i> får en POSTMAN-funktion där jag kan <i>GET</i> (<i>find()</i>), <i>POST</i> (<i>set()</i>) <i>und so weite</i>.

		<p>Snyggt upplägg med att man automatiskt skapar en klass med basmetoder i sin terminal som sedan blir <i>repository</i> och klass som man använder. Klasser är ju inget nytt vid det här laget, men repository-delen känns fortfarande ganska främmande och det jag kan dra som slutsats är att den är en typ av databashanterar med inbyggda kommandon matchade mot din databas variabler.
		Jag antar att man kan göra liknande manövrar utan att använda den automatgenererade versionen och istället skriva den manuellt (vilket man ju dock gärna slipper).</p>

		<p>Denna gång gjorde jag även en enkel skiss över min app och skrev lite pseudokod vilket jag upplever hjälper då man slipper börja göra delar som sedan inte visar sig vara så genomtänkta när den fulla strukturen växer fram. Trots detta inledde jag med tankefel avseende klassen och såg framför mig en library-klass som hade en metod som skapade en annan klass (bok-objekten), jag kom på mig själv ganska tidigt och insåg att databasen i sig själv fyller den förstnämnda funktionen så skada var minimal.</p>
   	    </p>

        <h3>Uppgiften</h3>
		<p>
		Jag tänkte primärt att grafiken för min app skulle vara enhetlig med sidan men kännas som en sammanhållen egen "funktion" när man besöker den delen. Detta försökte jag åstadkomma genom att återanvända så mycket CSS som möjligt för de olika delarna och se till att det fanns "retur"-knappar som navigerar inom subsidan.
		Ett annat sätt hade kunnat vara att låta bibliotektsvyn öppnas i ett <i>pop-up</i> som man istället kunnat hantera separat från den vanliga browservyn. Jag försöker nu permanent hålla mig till <i>rem</i>, <i>auto</i> och % när jag skriver min CSS för att den ska fungera på olika enheter samt skapar relativt stora knappar och läsbara tabeller, det är väl ungefär 
		så långt min användarvänlighetsinsats sträckte sig.
		</p>

		<p>Den, för mig, svåraste delen (som jag också sköt framför mig in i det sista) var filhanteringsbiten vid uppladdning av bokbild. Tidigare har jag bara använt bilder som jag redan själv manuellt lagt bland mina <i>assets</i>, nu skulle den laddas upp dit.
		Jag satt alldeles för länge och försökte använda det filnamn som jag fick när jag gjorde <i>GET</i> på min uppladdade fil (som bara returnerade ett strängvärde som sen inte hade en motsvarighet någonstans i min filstruktur då den inte lagrats permanent).
		Det tog alldeles för lång tid att lista ut att Symfony (givetvis) hade egen inbyggd funktionalitet för detta (man måste komma ihåg alla olika dokumentationer!!).
		Det var åtminstone lärorikt och jag fick skapa en ny parameter i min <i>services.yaml</i> och se till att den fil jag laddade upp sparades permanent (genom Symfonys <i>File</i>, <i>UploadedFile</i> och <i>FileException</i>).
		Nu fungerar det till slut! Jag noterade att man kan göra en uppsjö av kontroller för att styra upp vilken typ av bild som laddas upp men jag nöjde mig med att se till att den inte blir för stor (max 1 megabyte).</p>

		<p>
		Jag tycker att ORM var ett betydligt mer lättillgängligt sätt att jobba med databas, kanske har det begränsningar när datamängderna blir stora och man hellre vill kunna se dem i terminalen för att kontrollera olika sammanslagningar och dylikt. Jag förstod på uppgiften att jag även hade kunnat skapa en återställning likt den vi gjorde i <i>MariaDB</i> (skript för att nå olika stadier i SQL-programmeringen).
		Nu behövde vi ju inte göra några särskilt avancerade manövrar såsom <i>JOIN</i> eller annat som vi gjorde i Databasteknologier, men jag antar att ORM-upplägget kan hantera även sådant, annars är det väl där begränsningen tar vid. Även avseende mängden applikationskod som behöver skrivas kändes ORM som mer avskalat än vad <i>MariaDB</i> tillsammans med <i>JS</i> gjorde. Nu behöver jag inte skriva alla SQL-satser på egen hand för att skicka <i>request</i> och inte heller hålla på med massa visuella tabellskapar-metoder för att hantera <i>data-packet-row</i>, utan kan styla datan med CSS vilket går betydligt snabbare.
		</p>

        <h3>TIL</h3>
            <ul>
                <li><i>EntityManager->flush()</i> är central vid uppdateringar.</li>
                <li>PHP:s sätt att skicka med databas-variabler till Twig påminner mycket om JS-syntaxen och den "vanliga" datan vi skickat med andra router.</li>
                <li>Det är en klar fördel att inte bara skriva <i>thead</i> och <i>tbody</i> elementen och sen försöka styla dem, bli gråhårig, för att sen inse att man glömt omge dem av <i>table</i>-elementet</li>
                <li>Var noga med att uppdatera <i>path</i> när man återanvänder kod, jag satt länge och undrade varför min <i>update</i> duplicerade rader, testade massa olika saker tills jag såg att jag hade path till <i>'create'</i> på mitt formulär istället för att gå tillbaka till <i>show_all</i> som var tanken.</li>
                <li>Lurigt att hålla isär <i>redirectToRoute('book_show_all')</i> namnvariabel och </i>render('book/update.html.twig)</i> templatenamn när man sitter och skriver. Lyckligtvis ganska självförklarande felmeddelanden i browsern.</li>
                <li>Man kan dumpa databasen för att felsöka eller välja att visa den i terminalen.</li>
				<li><i>"$books = $entityManager->$bookRepository->findAll()"</i> verkar generera en sträng (ganska oanvändbar i template) medan $books = $entityManager->getRepository(Book::class)->findAll() ger ett objekt/array som går att iterera över.</li>
				<li>Håll isär syntaxen avseende 'id' => $id och 'id': book.id</li>
				<li>Symfony har inbyggda metoder för att hantera filuppladdning och allt relaterat till sådant.</li>
				<li>Tilde-tecknet är TWIG:s sätt att konkatenera.</li>		
            </ul>
</article>
